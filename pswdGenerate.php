<?php

/**
 * This file is for generating random passwords for a new user and
 * storing it in mysql database against the respective users.
 * It also encrypts generated passwords using apr1_md5 encryption
 * algorithms and updates the ingress auth secret with the new user
 * username and encrypted password so that this can be further used
 * for docker registery authentication.
 */

/**
 * PasswordGenerator Class Doc Comment
 *
 * PasswordGenerator is to generate random password
 * for a given user and encrypt it so that it can be
 * added as an entry to ingress auth secret.
 *
 */
class PasswordGenerator
{
    public $secretName = "docker-registry-secret";

    /**
     * generatePswd generates and encrypt random password
     * for a given user.
     * $username is the name/id of the new user
     */
    public function generatePswd($username)
    {
        $accessKey = $username;
        $random_password = $this->randomStrings(12);
        // to be saved in database (base64 encoded)
        $secretKey = base64_encode($random_password);

        /*
        // insert base64 encoded password in database
        global $wpdb;
        // update database with generated password
        $updated = $wpdb->update( "userCredentials", array( 'mod_docker_pass' => $secretKey ),
        array( 'mod_username' => $username )
        );
        if ( false === $updated ) {
        // There was an error.
        } else {
        // No error. You can check updated to see how many rows were changed.
        }
         */

        // encrypt generated password so that it
        // can be used by ingress auth
        $enc_password = $this->cryptApr1MD5($random_password);
        // to be entered into ingress auth secret
        $ingress_auth = $accessKey . ":" . $enc_password;

        $getSecretCmd = "kubectl get secret " . $this->secretName .
            " -o jsonpath='{.data.auth}'";
        exec($getSecretCmd, $output, $return_var);

        if ($return_var === 0) {
            $str_output = implode("", $output);
            echo $str_output, "\n";
            // decode the ingress auth secret password
            $decoded_pass = base64_decode($str_output);
            $new_pass = $decoded_pass . "\n" . $ingress_auth;
            $new_encoded_pass = base64_encode($new_pass);

            $patchJSON = '[{"op":"replace","path":"/data/auth","value":' .
                $new_encoded_pass . "}]";
            $patchOutput = "
            kubectl patch secret " . $this->secretName . " --type json -p " .
                "'" . $patchJSON . "'";
            // execute kubectl patch to update ingress auth secret with new entry
            exec($patchOutput, $output, $return_var);
            if ($return_var === 0) {
                echo implode("\n", $output), "\n";
            } else {
                echo "Failed to patch secret " . $this->secretName;
            }
        } else {
            echo "unable to get password of auth secret.";
            return;
        }

        // testing purpose
        echo $accessKey, " --- ", $random_password, " --- ", $secretKey, " --- ", $enc_password,
        " --- ", $ingress_auth, "\n";
    }

    /**
     *  This function will return a random string of specified length
     */
    private function randomStrings($length_of_string)
    {
        // random_bytes returns number of bytes
        // bin2hex converts them into hexadecimal format
        return substr(
            bin2hex(random_bytes($length_of_string)), 0, $length_of_string
        );
    }

    /**
     * @param string $password is the password that needs to be encrypted.
     * @param string|null $salt is used while encryption, if not given it will
     * be generated by the function itself.
     */
    public static function cryptApr1MD5($password, $salt = null)
    {
        if (!$salt) {
            $salt = substr(base_convert(bin2hex(random_bytes(6)), 16, 36), 1, 8);
        }
        $len = strlen($password);

        $text = $password . '$apr1$' . $salt;

        $bin = pack("H32", md5($password . $salt . $password));

        for ($i = $len; $i > 0; $i -= 16) {
            $text .= substr($bin, 0, min(16, $i));
        }

        for ($i = $len; $i > 0; $i >>= 1) {
            $text .= ($i & 1) ? chr(0) : $password[0];
        }

        $bin = pack("H32", md5($text));

        for ($i = 0; $i < 1000; $i++) {
            $new = ($i & 1) ? $password : $bin;

            if ($i % 3) {
                $new .= $salt;
            }

            if ($i % 7) {
                $new .= $password;
            }

            $new .= ($i & 1) ? $bin : $password;
            $bin = pack("H32", md5($new));
        }

        $tmp = '';

        for ($i = 0; $i < 5; $i++) {
            $k = $i + 6;
            $j = $i + 12;

            if ($j == 16) {
                $j = 5;
            }

            $tmp = $bin[$i] . $bin[$k] . $bin[$j] . $tmp;
        }

        $tmp = chr(0) . chr(0) . $bin[11] . $tmp;
        $tmp = strtr(
            strrev(substr(base64_encode($tmp), 2)),
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
        );

        return "$" . "apr1" . "$" . $salt . "$" . $tmp;
    }
}

$pswdGeneratorObj = new PasswordGenerator();

// call generatePswd with some username
$pswdGeneratorObj->generatePswd("sagar");
